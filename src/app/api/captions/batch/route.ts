
import type { NextRequest} from 'next/server';
import { NextResponse } from 'next/server';
import { generateImageCaption, type GenerateImageCaptionInput } from '@/ai/flows/generate-image-caption';

interface BatchCaptionResult {
  imageUrl: string;
  caption?: string;
  error?: string;
}

async function processUrl(url: string, targetLanguage?: string, maxWords?: number): Promise<BatchCaptionResult> {
  try {
    if (!url) {
      return { imageUrl: url, error: 'Image URL is empty or invalid.' };
    }
    // Fetch the image
    const imageResponse = await fetch(url);
    if (!imageResponse.ok) {
      return { imageUrl: url, error: `Failed to fetch image (status: ${imageResponse.status})` };
    }

    // Convert image to data URI
    const arrayBuffer = await imageResponse.arrayBuffer();
    const buffer = Buffer.from(arrayBuffer);
    const mimeType = imageResponse.headers.get('content-type') || 'image/jpeg';
    if (!mimeType.startsWith('image/')) {
        return { imageUrl: url, error: `Invalid content type: ${mimeType}. URL does not point to a valid image.` };
    }
    const photoDataUri = `data:${mimeType};base64,${buffer.toString('base64')}`;

    const captionInput: GenerateImageCaptionInput = { photoDataUri };
    if (targetLanguage) {
      captionInput.targetLanguage = targetLanguage;
    }
    if (maxWords && typeof maxWords === 'number' && maxWords > 0) {
      captionInput.maxWords = maxWords;
    }

    const result = await generateImageCaption(captionInput);
    if (result.caption) {
      return { imageUrl: url, caption: result.caption };
    } else {
      return { imageUrl: url, error: 'Caption could not be generated by the model.'};
    }
  } catch (error: any) {
    console.error(`Error processing URL ${url}:`, error);
    return { imageUrl: url, error: error.message || 'An unknown error occurred while processing this image.' };
  }
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const imageUrls = body.imageUrls as string[];
    const targetLanguage = body.targetLanguage as string | undefined;
    const maxWords = body.maxWords as number | undefined;

    if (!imageUrls || !Array.isArray(imageUrls) || imageUrls.length === 0) {
      return NextResponse.json({ error: 'imageUrls array is required and cannot be empty' }, { status: 400 });
    }
    
    // Limit concurrent requests to avoid overwhelming the server or external services.
    // This is a simple concurrency limiter. For more robust solutions, consider libraries like p-limit.
    const MAX_CONCURRENT_REQUESTS = 5; 
    const results: BatchCaptionResult[] = [];
    
    for (let i = 0; i < imageUrls.length; i += MAX_CONCURRENT_REQUESTS) {
        const batchUrls = imageUrls.slice(i, i + MAX_CONCURRENT_REQUESTS);
        const batchPromises = batchUrls.map(url => processUrl(url, targetLanguage, maxWords));
        const batchResults = await Promise.all(batchPromises);
        results.push(...batchResults);
    }

    return NextResponse.json({ results });

  } catch (error: any) {
    console.error('Error in batch caption endpoint:', error);
    return NextResponse.json({ error: error.message || 'An error occurred processing the batch request' }, { status: 500 });
  }
}
